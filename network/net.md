##OSI参考模型
Open System Interconnect,开发系统互联，是一个七层的计算机网络模型，分别为：

- 物理层： 在网络上透明地传送比特流
- 数据链路层： 管理物理层的比特数据，并将正确的数据传送到没有传输错误的路线中。重要协议:点对点协议PPP（点对点通信方式）、CSMA/CD协议（一对多的广播通信方式）
- 网络层：网络层的作用是决定如何将发送方的数据传到接收方。该层通过考虑网络拥塞程度、服务质量、发送优先权、每次路由的耗费来决定节点X到节点Y的最佳路径。我们熟知的路由器就工作在这一层，通过不断的接收与传送数据使得网络变得相互联通。重要的协议：IP协议、ARP协议、RARP协议、ICMP协议、IGMP协议
- 传输层：为两个主机中进程之间的通信提供服务，负责数据分割（传送端）和数据组合（接收端）以及控制数据流量，并且进行调试及错误处理，以确保通信顺利。常见的协议：TCP协议、UDP协议
- 会话层：为网络中两个结点（通信双方）制定通信方式，并建立、维护、控制、注销会话等。
- 表示层：负责数据的编码和转化，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取（相互识别）。同时，也能提供数据的压缩、解压、加密、解密。
- 应用层：应用层能与应用程序界面沟通，以达到展示给用户的目的。 在此常见的协议有: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。

##网络层协议
- IP协议

	根据目的IP地址，找一条路径，将发送方的数据传到接收方
- ARP协议：地址解析协议

	根据对方的IP地址，找到对方的物理地址
- RARP协议：逆地址解析协议

	根据对方的硬件地址，找到对方的IP地址
- ICMP协议：网际控制报文协议(Internet Control Message Protocol)

	数据报发送错误时，发送提示信息
- IGMP协议：网际组管理协议

	发送多播协议
- OSPF协议：开放最短路径优先

	发送数据找一条最短路径发送

##ping命令作用？使用的什么协议？
作用:它测试两个主机之间的连通性。

使用网络层协议ICMP协议
##TCP和UDP区别
TCP是传输控制协议，提供的是面向连接、可靠的字节流服务。当客户端和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发、丢弃重复数据、检验数据、流量控制等功能。保证数据能从一端传到另一端。

UDP是用户数据报协议，是一个简单的面向数据报的传输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不保证它们能够到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发机制，故而传输速度很快。

##TCP的3次握手和4次挥手
TCP报文格式：

![TCP报文格式](https://github.com/XFHNever/JobPrepare/tree/master/images/net1-1.png)

上图中有几个字段需要重点介绍下：

1. 序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
2. 确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
3. 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：

		（A）URG：紧急指针（urgent pointer）有效。
		（B）ACK：确认序号有效。
		（C）PSH：接收方应该尽快将这个报文交给应用层。
		（D）RST：重置连接。
		（E）SYN：发起一个新连接。
		（F）FIN：释放一个连接。

####三次握手
所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：

![三次握手](https://github.com/XFHNever/JobPrepare/tree/master/images/net1-2.png)

- 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
- 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
- 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

######SYN攻击：

在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：

	#netstat -nap | grep SYN_RECV

####四次挥手
四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：

![四次挥手](https://github.com/XFHNever/JobPrepare/blob/master/images/net1-4.jpg)

由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

- 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
- 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
- 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
- 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

####为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。
##
