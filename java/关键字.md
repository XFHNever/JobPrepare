##final##
1. 与变量一起使用

	被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。

	对与java中的final变量，java编译器是进行了优化的。每个使用了final类型变量的地方都不会通过连接而进行访问。比如说Test类中使用了Data类中一个final的int数字fNumber=77，这时候，java编译器会将77这个常数编译到Test类的指令码或者常量池中。这样，每次Test类用到fNumber的时候，不会通过引用连接到Data类中进行读取，而是直接使用自己保存在类文件中的副本。

	final关键字只能保证变量本身不能被赋与新值，而不能保证变量的内部结构不被修改。比如：

		final String[] color = { "red", "blue", "yellow", "black" }
	执行
	
		color = new String[]{""};
	就会报错，但是下面的操作时可以正常执行的：

		color[3] = "white";
2. 与方法一起使用

	被声明为final的方法也同样只能使用，不能重载。

	同时final方法也是高效的，编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。 

	调用一个函数除了函数本身的执行时间之外，还需要额外的时间去寻找这个函数（类内部有一个函数签名和函数地址的映射表）。所以减少函数调用次数就等于降低了性能消耗。 

	final修饰的函数会被编译器优化，优化的结果是减少了函数调用的次数。编译器直接将func的函数体内嵌到了调用函数的地方。

	不过，当函数体太长的话，用final可能适得其反，因为经过编译器内嵌之后代码长度大大增加，于是就增加了jvm解释字节码的时间。 所以被final修饰的方法体不能过大，编译器可能会放弃内联。
3. 与类一起使用

	如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承（该类所有方法都是final）。因此一个类不能既被声明为 abstract的，又被声明为final的。

如果一个变量或方法参数被final修饰，就表示它只能被赋值一次，但是JAVA虚拟机为变量设定的默认值不记作一次赋值。

被final修饰的变量必须被初始化。初始化的方式有以下几种：

1. 在定义的时候初始化。  

2. final变量可以在初始化块中初始化，不可以在静态初始化块中初始化。  

3. 静态final变量可以在静态初始化块中初始化，不可以在初始化块中初始化

4. final变量还可以在类的构造器中初始化，但是静态final变量不可以。

##finally##
它只能用在try/catch语句中，并且附带着一个语句块，表示这段语句最终总是被执行。

return、continue、break这三个可以打乱代码顺序执行语句的关键字也不能影响finally语句块的执行。

return语句的作用是退出当前的方法，并将值或对象返回。如果finally语句块是在return语句之后执行的，那么return语句被执行后就已经退出当前方法了，finally语句块又如何能被执行呢？因此，正确的执行顺序应该是这样的：编译器在编译return new ReturnClass();时，将它分成了两个步骤，new ReturnClass()和return，前一个创建对象的语句是在finally语句块之前被执行的，而后一个return语句是在finally语句块之后执行的，也就是说finally语句块是在程序退出方法之前被执行的。同样，finally语句块是在循环被跳过（continue）和中断（break）之前被执行的。 

try里面是有System.exit(0)来退出JVM的情况下finally块中的代码不会执行。
##finalize##
方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。

当垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。值得C++程序员注意的是，finalize()方法并不能等同与析构函数。Java中是没有析构函数的。C++的析构函数是在对象消亡时运行的。由于C++没有垃圾回收，对象空间手动回收，所以一旦对象用不到时，程序员就应当把它delete()掉。所以析构函数中经常做一些文件保存之类的收尾工作。但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。

那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。

##Static##

1. static变量

	声明为static的变量实质上就是全局变量。当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例变量共用同一个static变量。静态变量与静态方法类似。所有此类实例共享此静态变量，也就是说在类装载时，只分配一块存储空间，所有此类的对象都可以操控此块存储空间。
2. static方法

	静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。
3. static代码块

	static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。
4. static类

    普通类是不允许声明为静态的，只有内部类才可以。被static修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类。

##private、protected和public
<table width="90%" bgcolor="#ffffff">
<tbody>
<tr align="center" bgcolor="#747474" valign="center">
<td height="25">作用域</td>
<td>当前类</td>
<td>同一package</td>
<td>子孙类</td>
<td>其他package</td></tr>
<tr align="center" valign="center">
<td align="center" height="25">public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td></tr>
<tr align="center" valign="center">
<td align="center" height="25">protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td></tr>
<tr align="center" valign="center">
<td align="center" height="25">friendly</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td></tr>
<tr align="center" valign="center">
<td align="center" height="25">private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td></tr></tbody>
</table>

##override和overload的区别
####override（重写，覆盖） 

1. 方法名、参数、返回值相同。
2. 子类方法不能缩小父类方法的访问权限。
3. 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。
4. 存在于父类和子类之间。
5. 方法被定义为final不能被重写。 

####overload（重载，过载） 

1. 参数类型、个数、顺序至少有一个不相同。  
2. 不能重载只有返回值不同的方法名。
3. 存在于父类和子类、同类中。 

方法的重写(Overriding)和重载(Overloading)是Java多态性的不同表现。
重写(Overriding)是父类与子类之间多态性的一种表现，而重载(Overloading)是一个类中多态性的一种表现。

如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了. 

如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型或有不同的参数次序，则称为方法的重载(Overloading)。不能通过访问权限、返回类型、抛出的异常进行重载. 

####Override 特点 
1. 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；
2. 覆盖的方法的返回值必须和被覆盖的方法的返回一致；
3. 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；
4. 被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 

####Overload 特点 
1. 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）；
2. 不能通过访问权限、返回类型、抛出的异常进行重载；
3. 方法的异常类型和数目不会对重载造成影响；
4. 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。