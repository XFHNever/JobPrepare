##final##
1. 与变量一起使用

	被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。

	对与java中的final变量，java编译器是进行了优化的。每个使用了final类型变量的地方都不会通过连接而进行访问。比如说Test类中使用了Data类中一个final的int数字fNumber=77，这时候，java编译器会将77这个常数编译到Test类的指令码或者常量池中。这样，每次Test类用到fNumber的时候，不会通过引用连接到Data类中进行读取，而是直接使用自己保存在类文件中的副本。

	final关键字只能保证变量本身不能被赋与新值，而不能保证变量的内部结构不被修改。比如：

		final String[] color = { "red", "blue", "yellow", "black" }
	执行
	
		color = new String[]{""};
	就会报错，但是下面的操作时可以正常执行的：

		color[3] = "white";
2. 与方法一起使用

	被声明为final的方法也同样只能使用，不能重载。

	同时final方法也是高效的，编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。 

	调用一个函数除了函数本身的执行时间之外，还需要额外的时间去寻找这个函数（类内部有一个函数签名和函数地址的映射表）。所以减少函数调用次数就等于降低了性能消耗。 

	final修饰的函数会被编译器优化，优化的结果是减少了函数调用的次数。编译器直接将func的函数体内嵌到了调用函数的地方。

	不过，当函数体太长的话，用final可能适得其反，因为经过编译器内嵌之后代码长度大大增加，于是就增加了jvm解释字节码的时间。 所以被final修饰的方法体不能过大，编译器可能会放弃内联。
3. 与类一起使用

	如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承（该类所有方法都是final）。因此一个类不能既被声明为 abstract的，又被声明为final的。

如果一个变量或方法参数被final修饰，就表示它只能被赋值一次，但是JAVA虚拟机为变量设定的默认值不记作一次赋值。

被final修饰的变量必须被初始化。初始化的方式有以下几种：

1. 在定义的时候初始化。  
2. final变量可以在初始化块中初始化，不可以在静态初始化块中初始化。  
3. 静态final变量可以在静态初始化块中初始化，不可以在初始化块中初始化
4. final变量还可以在类的构造器中初始化，但是静态final变量不可以。
##finally##
它只能用在try/catch语句中，并且附带着一个语句块，表示这段语句最终总是被执行。

return、continue、break这三个可以打乱代码顺序执行语句的关键字也不能影响finally语句块的执行。

return语句的作用是退出当前的方法，并将值或对象返回。如果finally语句块是在return语句之后执行的，那么return语句被执行后就已经退出当前方法了，finally语句块又如何能被执行呢？因此，正确的执行顺序应该是这样的：编译器在编译return new ReturnClass();时，将它分成了两个步骤，new ReturnClass()和return，前一个创建对象的语句是在finally语句块之前被执行的，而后一个return语句是在finally语句块之后执行的，也就是说finally语句块是在程序退出方法之前被执行的。同样，finally语句块是在循环被跳过（continue）和中断（break）之前被执行的。 

try里面是有System.exit(0)来退出JVM的情况下finally块中的代码不会执行。
##finalize##
方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。

当垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。值得C++程序员注意的是，finalize()方法并不能等同与析构函数。Java中是没有析构函数的。C++的析构函数是在对象消亡时运行的。由于C++没有垃圾回收，对象空间手动回收，所以一旦对象用不到时，程序员就应当把它delete()掉。所以析构函数中经常做一些文件保存之类的收尾工作。但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。

那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。
##Static##
