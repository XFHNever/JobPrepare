##线程与进程的区别联系
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，
它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），
但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。

####区别
######从属关系
一个线程只属于一个进程，但是进程可以拥有多个线程，且至少拥有一个线程
######资源
无论是传统的还是现在的OS系统中，进程拥有资源，都是资源分配的基本单位

线程不拥有系统资源，而仅仅包含一点能够支撑自己运行的资源，使得线程能够轻装上阵，从而显著提高系统的并发性。但是它可以访问它所隶属进程的资源。
######并发性
在传统的OS中，仅仅是进程之间可以并发。

在引入线程后，不仅进程之间可以并发，属于一个进程的多个线程也可以并发，使得OS有较好的并发性，从而提高资源利用率和系统吞吐量。
######系统开销
进程在创建、销毁、切换、通信、同步代价都比较大

- 在创建和撤销进程时，OS需要创建和回收进程控制块，分配和回收资源，OS付出的代价比较大。线程仅仅需要创建和回收线程控制块。
- 在进程进行切换时，OS需要保存当前环境以及新被调度进程的环境，而线程仅仅需要保存和设置少量寄存器即可。除此之外属于同一个进程的线程相互切换时不会引起线程的切换，但是属于不同进程的线程相互切换时，会引起进程切换。
- 在线程进行通信和同步时，属于同一个进程的多个线程具有相同的地址，所以通信和同步代价会容易点。

##进程通信方式有哪些
- 管道： 管道中还有命名管道和非命名管道之分，非命名管道只能用于父子进程通讯，命名管道可用于非父子进程，命名管道就是FIFO，管道是先进先出的通讯方式。FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO，因此也成为命名管。
- 消息队列： 是用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。需要注意的是，消息队列是用创建文件的方式建立的，如果一个进程向某个消息队列中写入了数据之后，另一个进程并没有取出数据，即使向消息队列中写数据的进程已经结束，保存在消息队列中的数据并没有消失，也就是说下次再从这个消息队列读数据的时候，就是上次的数据！！！
- 信号量( semophore ) ： 不能传递复杂消息，只能用来同步
- 共享内存： 只要首先创建一个共享内存区，其它进程按照一定的步骤就能访问到这个共享内存区中的数据，当然可读可写；
- 信号 ( sinal ) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- 套接字( socket ) ：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。****

几种方式的比较：

- 管道：速度慢，容量有限
- 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
- 信号量：不能传递复杂消息，只能用来同步
- 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。

##请列举下不同进程之间共享数据的方式
1. 文件映射(Memory-Mapped Files)能使进程把文件内容当作进程地址间一块内存那样来对待
2. 共享内存(Shared Memory)实际就是文件映射的一种特殊情况
3. 命名管道(Named Pipe)是服务器进程和一个或多个客户进程之间通信的单向或双向管道
4. 邮件槽(Mailslots)提供进程间单向通信能力，任何进程都能建立邮件槽成为邮件槽服务器
5. 剪贴板(Clipped Board)为不同应用程序之间共享不同格式数据提供了一条捷径
6. 动态连接库(DLL)中的全局数据可以被调用DLL的所有进程共享

##同步的方式有哪些
线程同步指多个线程同时访问某资源时，采用一系列的机制以保证同时最多只能一个线程访问该资源。线程同步是多线程中必须考虑和解决的问题，因为很可能发生多个线程同时访问（主要是写操作）同一资源，如果不进行线程同步，很可能会引起数据混乱，造成线程死锁等问题；



####线程同步的方式：
- 临界区：通过对多线程的串行化来访问公共资源或者一段代码，速度快，适合控制数据访问
- 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会同时被多个线程访问
- 信号量：它允许多个线程同一时刻访问同一资源，但是需要限制同一时刻访问此资源的最大线程数目。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中PV操作相似。
- 事件（信号）：通过通知操作的方式来保持多线程的同步，还可以方便的实现多线程的优先级比较的操作

####总结比较
- 互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。
-   互斥量（Mutex），信号灯（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作，而其他的对象与数据同步操作无关，但对于进程和线程来讲，如果进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以可以使用WaitForSingleObject来等待进程和线程退出。
- 通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号灯对象可以说是一种资源计数器。

##线程的实现方式. (也就是用户线程与内核线程的区别)
根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程。

内核线程建立和销毁都是由操作系统负责、通过系统调用完成的，操作系统在调度时，参考各进程内的线程运行情况做出调度决定，如果一个进程中没有就绪态的线程，那么这个进程也不会被调度占用CPU。 
和内核线程相对应的是用户线程，用户线程指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，用户进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。用户线程多见于一些历史悠久的操作系统，例如Unix操作系统，不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少为了在操作系统中加入线程支持，采用了在用户空间增加运行库来实现线程，这些运行库被称为“线程包”，用户线程是不能被操作系统所感知的。 引入用户线程，具体而言，有以下四个方面的优势： 

- 可以在不支持线程的操作系统中实现。 
- 创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。
- 允许每个进程定制自己的调度算法，线程管理比较灵活。
- 线程能够利用的表空间和堆栈空间比内核级线程多。 
 
用户线程的缺点主要有以下两点： 

- 同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。 
- 页面失效也会产生类似的问题。 

内核线程的优缺点刚好跟用户线程相反。实际上，操作系统可以使用混合的方式来实现

##用户态和核心态的区别、用户栈和内核栈的区别。
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。 

用户态切换到内核态的3种方式：系统调用、异常、外围设备中断。

##ThreadLocal与其它同步机制的比较
Threadlocal和其他所有的同步机制都是为了解决多线程中的对同一变量的访问冲突，在普通的同步机制中，是通过对对象加锁来实现多个线程对同一变量的安全访问的。这时该变量是多个线程共享的，使用这种同步机制需要很细致的分析在什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放该对象的索等等。所有这些都是因为多个线程共享了该资源造成的。Threadlocal就从另一个角度来解决多线程的并发访问，Threadlocal会为每一个线程维护一个和该线程绑定的变量副本，从而隔离了多个线程的数据共享，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。

当然ThreadLocal并不能替代同步机制，两者面向的问题领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式；而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源（变量），这样当然不需要对多个线程进行同步了。所以，如果你需要进行多个线程之间进行通信，则使用同步机制；如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal，这将极大地简化你的程序，使程序更加易读、简洁。
##进程死锁的条件

**定义：**所谓死锁就是一个进程集合中的多个进程因为竞争资源，而造成的互相等待现象。

**原因：**系统资源不足；多个进程的推进顺序不合理

**必要条件：**

- 互斥条件（Mutual exclusion）：资源不能被共享，只能由一个进程使用。
- 请求与保持条件（Hold and wait）：已经得到资源的进程可以再次申请新的资源。
- 非剥夺条件（No pre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
-  循环等待条件（Circular wait）：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

**处理策略：**

- 忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的情况下。传说中，鸵鸟看到危险就把头深埋地下，这是显然是一种很消极的策略。
- 检测死锁并且恢复。
- 通过对资源有序分配，以避免循环等待的“环路”发生。
- 通过破坏死锁的必要条件，来防止死锁的产生。

##资源调度算法
实质是资源分配（分配CPU）的方式

- 先来先服务算法（FCFS）

	思想：总是选择一个最先进入队列的进程，为之分配处理器，一直到进程执行结束或者阻塞而放弃处理机。

	特点：属于非抢占式调度。
	
	缺点：
	
	<1> 仅考虑进程的等待时间，有利于长进程，不利于短进程。
	
	<2> 实时性不好，未考虑进程的紧迫程度。
	
	影响：会导致短进程（执行时间短）等待时间太长，使得短进程的周转时间太长（执行时间 - 到达时间）。
	
	评价：先来先服务算法有利于CPU繁忙型（执行时间长）的进程，而不利于IO繁忙型（执行时间短）的进程。
- 短作业优先算法

	思想：总是先执行运行时间短的进程。
	
	特点：可以是抢占式调度，也可以是非抢占式调度。
	
	缺点：
	
	<1> 进考虑进程的运行时间，对长进程不利，会出现长进程饿死现象。
	
	<2> 实时性不好，未考虑进程的紧迫程度。
	
	<3> 进程的运行时间是估计值，不能准确衡量短进程。
	
	优点：能有效地降低所有进程的平均等待时间，提高系统的吞吐量。（体现在数据上，其实就是降低短进程的等待时间，使得进程的平均周转时间和平均等待时间都降低）	
- 高优先权优先调度算法
	
	思想：总是先执行优先级高的进程。
	
	特点：可以是抢占式调度，也可以是非抢占式调度。
	
	分类：根据获得优先权时间可以分为两类：
	
	（1）静态优先权
	
	特点：创建进程时分配。
	
	优点：简单易行，系统开销小。
	
	缺点：不够精确，而且很可能出现优先权低的进程得不到调度的情况（饿死）
	
	（2）动态优先权
	
	特点：进程的优先权能够随着进程的推进和等待时间而改变。
	
	典型代表：高响应比优先调度算法。
	
	进程优先级 = 1 + （等待时间 / 要求服务时间）。
	
	优点：折中了短作业优先 + 先来先服务。即照顾短进程，又考虑进程到达的先后顺序，不会使得作业长期得不到服务。
- 基于时间片的轮转算法

	思想：先来先服务 + 时间片轮转。
	
	特点：抢占式调度（执行不完，也得闪人）。
- 多级反馈队列调度算法

	思想：
	
	（1）在多个队列间，属于高优先级优先调度。
	
	（2）在队列内，属于先来先服务 + 时间片轮转。
	
	特点：抢占式调度
	
	优点：不必知道各个进程需要的执行时间，而且还可以满足各种类型的进程的需要。
	
	硬件设置：
	
	<1> 设置多个就绪队列，
	
	<2> 在不同的队列间设置不同的优先级，且优先级下降（越下面的队列优先级越小）。
	
	<3> 在不同的队列内设置不同的时间片，且时间片上升（越下面的队列中时间片越长）。
	
	工作方式：
	
	<1> 新进程进入第一队列末尾，按先来先服务排队等待调度。
	
	<2> 能在一个时间片内执行完，则可以直接离开os，不能在时间片执行完，在放入第二队列。...。
	
	<3> 若到最后一个队列仍没有执行完，则放到本队列的队尾，继续循环执行。
	
	注意：
	
	<1> 当前i-1个队列为空时，才能调度第i个队列的进程。
	
	<2> 若第i个队列中的进程A正在执行，但是有进程B进入第1个队列，此时进程A被强占了CPU，之后应该放到所在队列的队尾，等待执行。注意，不是放入下一队列。

##操作系统的内存管理淘汰算法有哪些
1. FIFO先进先出的算法
    
    FIFO算法总是选择在内存驻留时间最长的一页将其淘汰。FIFO算法认为先调入内存的页不再被访问的可能性要比其他页大，因而选择最先调入内存的页换出。实现FIFO算法需要把各个已分配页面按分配时间顺序记录在一个数组中，每次淘汰最早进入数组的页。
2. OPT最佳淘汰算法描述：

    该算法淘汰在访问串中将来最不常用的页。这样，淘汰掉该页将尽量减少因需要访问该页又立即把它调入的现象。遗憾的是，这种算法无法实现，因为它要求必须预先知道每一个进程的访问串。
3. LRU最近最少使用算法

    LRU工作原理是，当需要淘汰某页，选择离当前时间最近的一段时间内最久没有使用过的页先淘汰。在这里采用一个页面集大小的栈存储最近访问的页面。页面按时间顺序压如栈中。如果被访问的页在栈中，则从栈中移出页面，压入栈顶。这样栈底记录离当前时间最近的一段时间内最久没有使用过的页。
4. LFU最少访问页面算法

    LFU在需要淘汰某一页时，首先淘汰到当前时间为止、被访问次数最少的那一页。这只要在页面集中给每一页增设一个访问计数器即可实现。每当该页被访问时，访问计数器加1，而发生一次缺页中断时，则淘汰计数值最小的那一页，并将所有的计数器清零。
5. NUR最近最不经常使用算法

    NRU在需要淘汰某一页时，从那些最近一个时期内未被访问的页中任选一页淘汰。只要在页表中增设一个访问位即可实现。当某页被访问时，访问位置1。否则，访问位置0。系统周期性地对所有引用位清零。当需淘汰一页时，从那些访问位为零的页中选一页进行淘汰。如果引用位全0或全1，NRU算法退化为FIFO算法。

##

